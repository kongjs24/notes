#### 클린소프트웨어 발췌

---

상속과 위임은 모두 상위 단계의 알고리즘을 하위 단계의 구체적인 부분으로부터 분리해주는 역할을 한다. 둘 다 상위 단계의 알고리즘이 구체적인 부분과 독립적으로 재사용될 수 있게 해준다. 약간의 복잡성과 메모리, 실행 시간을 더 감내하면 위임은 구체적인 부분이 상위 단계 알고리즘으로부터 독립적으로 재사옹될 수 있게까지 해준다.

# 인터페이스

---

자바 인터페이스를 사용하는 것은 "여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다." 라고 이야기하는 것과 같다.

하나의 클래스는 여러 인터페이스를 구현한다고 선언할 수 있다.

## 인터페이스의 문제점

인터페이스를 조금이라도 바꾸거나 추가하면, 그 인터페이스를 구현하는 모든 클래스를 수정해야 한다.

인터페이스를 사용해서 커뮤니케이션에 방해가 되는 한 가지 요인이 있다면, 모든 연신이 공용\(public\)이라는 점이다.

# 추상클래스

---

하위클래스를 선언하는 것은 "이 객체는 상위클래스와 같다. 이 부분만 제외하면..." 이라 말하는 것과 같다.

상속 자체는 간단해 보이고 사용하기도 편리하게 느껴지지만 사실 많은 한계점이 있다.

상위클래스의 변경이 있을 때 모든 하위클래스를 변경할 수 있다.\(인터페이스도 구현체가 모두 변경될 수 있다.\)

하위클래스는 상위클래스의 기능을 직접 사용할 수 있다.\(코드 레벨로 제한할 수 없다. 그래서 어디선가 상위 클래스의 기능을 사용한다면 유지보수가 어려워진다.\)

## 하위클래스의 문제점

1. 하위클래스를 사용하면 되돌리기가 쉽지 않다. 추상클래스를 사용한 후 하위클래스가 표현하고자 하는 변형을 효과적으로 나타내지 못한다고 생각되면 하위클래스를 통해 얽혀 있는 코드를 모두 정리해줘야 한다. 
2. 하위클래스를 이해하기 위해서는 먼저 상위클래스를 이해해야 한다. 상위클래스가 점점 복잡해지면서 이 문제는 더욱 심각해진다.
3. 하위클래스가 상위클래스 세부 구현 특성에 의존할 수 있으므로 상위클래스의 수정이 위험해진다. 
4. 클래스 상속 계층이 복잡해지면서 이 모든 문제가 심화된다.

상속을 사용할 때 특히 치명적인 문제는 병렬 클래스 계층을 이용하는 경우이다. 이 경우, 하나의 클래스 계층에 있는 각 하위클래스에 대해 다른 클래스 계층에 대응되는 하위클래스가 필요하다. 이는 일종의 중복으로서, 클래스 계층간 암묵적 의존관계를 형성한다.

![](/assets/하위클래스의_단점.png)

위 그림은 뭔가 잘못 되어있다. 보험 계약은 연금 상품을 참조하면 안 된다. 그렇다고 계약 클래스에서 상품을 참조하게 하는 것도 그다지 매력적이지 않다. 이럴 경우 해결책은 계약 클래스가 보험 상품과 연금 상품에 상관 없이 동작하게 하는 방법이 있다.\(물론 다른 방법이 있을 수 있음\)

![](/assets/하위클래스_개선.png)

위 그림에서 처럼 현금흐름 이라는 클래스가 생겨 병렬 클래스 계층이용을 방지할 수 있다.

**조건문을 사용한 경우, 하위클래스를 사용한 경우, 위임을 사용한 경우를 모두 상상해보라. 그리고 상대적 강점이 있는 전략을 구현하고 코드가 향상되었는지 살펴보라**

하위크래스 사용을 제한하는 마지막 요소는 동적으로 변화하는 로직을 나타낼 수 없다는 것이다. \(컴파일 타임 의존\) 하위클래스를 사용하는 경우, 객체를 생성할 때 그 객체의 목적을 알아야하며 이는 이후에 바뀔 수 없다. 변화하는 로직을 나타낼 때는 조건문이나 위임을 사용하라.

# 인스턴스별 행위

---

이론상 클래스의 인스턴스들은 모두 같은 로직을 공유한다.

인스턴스별 행동에 따른 비용은 더욱 커진다. 코드를 쉽게 이해시키기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 ㅍㅕㄴ이 좋다.

## 조건문

가장 단순한 인스턴스별 행위의 형태는 if, switch 구문을 이용하는 것이다. 조건문을 사용하면 데이터에 따라 인스턴스는 다른 로직을 수행하게 된다. 조건문의 장점은 인스턴스별 행동을 지원하면서도 모든 로직이 하나의 클래스 안에 들어있다는 것이다.

조건문이 들어간 메소드를 호출하는 코드가 많으면 많을수록 프로그램에 문제가 있을 확률이 높아진다.

아래와 같은 코드가 있을 때 display\(\) 함수를 사용하는 어느 한곳에 기능이 변경되면 display\(\) 내부의 로직이 변경되어야 하고 내부의 로직이 변할 때 또 조건문이 들어가야한다. 추가적으로 조건문이 복사되면 문제는 심각해진다.

```java
class Figure {
    public void display() {
        switch (getType()) {
            case RECTABLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }

    public boolean contains(Point p) {
        switch (getType()) {
            case RECTABLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }
}
```

위 Figure 클래스에서 새로운 도형을 지원해야 한다고 생각해보자. 먼저 모든 switch 문에 새로운로직을 삽입해야한다. 또 기존 코드에 문제가 발생하는 위험을 감수하고, Figure 클래스를 직접 수정해야 한다. 게다가 **새로운 도형 **을 추가하려는 사람들은 같은 클래스의 비슷한 로직 변경을 모두 공유해야한다.

이와 같은 문제는 하위클래스나 위임 중 더 적합한 방법을 사용해서 조건문을 메시지\(다른 객체의 함수 호출\) 로 바꾸면 해결할 수 있다.

![](/assets/추상메소드와_위임.png)

조건문은 단순성과 지역성에서 장점이 있지만, 광법위하게 사용되는 경우 이러한 장점이 문제가 될 수도 있다.

## 위임

인스턴스별 다른 행위를 수행하는 다른 방법으로는 위임이 있다.

위임을 사용하는 예로 그래픽 편집기에서 사용자 입력을 처리하는 경우를 생각해보자. 그래픽 편집기에서 버튼을 누르면 "직사각형", "원","도형이동"을 수행해야 할 수도있다.

조건문 대신 하위클래스나 위임을 선택하면 된다. 프로그램 수행 도중에 편집기가 도구를 바꿔야 하기 때문에 하위클래스는 적당한 해결책이 아니다. 아래와 같이 위임을 통해 코드에 유연성을 부여할 수 있다.

하지만 mouseDown\(\) 메소드가 여러 클래스에 분산되어 구현되므로\(하위클래스도 마찬가지\) 코드를 읽기 어려워졌다. 또한 편집기의 동작을 이해하기 위해서는 어떤 도구가 현재 사용되고 있는지 알아야한다.\(하위클래스에서는 컴파일 타임 의존이므로 알기 쉽다.\)

```java
GraphicEditor
public void mousDown() {
    getTool().mouseDown(this);
}

RectangleTool
public void mouseDown(GraphicEditor editor) {
    editor.add(new RectableFigure());
}
```

위의 코드는 위임에 좀더 용용된 위임자 클래스\(editor\)를 위임 메소드\(mouseDown\)에 인자로 넘겨주는 방식으로 사용한다. 위임을 사용해서 자기 자신에게 메시지를 보낸다면\(위 코드에서 editor.add 메소드를 호출하는 부분\) 자기 자신\(editor\)이 무엇인지 분명하지 않다.

이런 유연성이 불필요하다면 아래와 같이 필드참조로 가지고 있는 것이 간단하다.

# 결론

---

#### 클린소프트웨어 발췌

---

상속과 위임은 모두 상위 단계의 알고리즘을 하위 단계의 구체적인 부분으로부터 분리해주는 역할을 한다. 둘 다 상위 단계의 알고리즘이 구체적인 부분과 독립적으로 재사용될 수 있게 해준다. 약간의 복잡성과 메모리, 실행 시간을 더 감내하면 위임은 구체적인 부분이 상위 단계 알고리즘으로부터 독립적으로 재사옹될 수 있게까지 해준다.

# 인터페이스

---

# 추상클래스

---

하위클래스를 선언하는 것은 "이 객체는 상위클래스와 같다. 이 부분만 제외하면..." 이라 말하는 것과 같다.

상속 자체는 간단해 보이고 사용하기도 편리하게 느껴지지만 사실 많은 한계점이 있다.

상위클래스의 변경이 있을 때 모든 하위클래스를 변경할 수 있다.\(인터페이스도 구현체가 모두 변경될 수 있다.\)

하위클래스는 상위클래스의 기능을 직접 사용할 수 있다.\(코드 레벨로 제한할 수 없다. 그래서 어디선가 상위 클래스의 기능을 사용한다면 유지보수가 어려워진다.\)

## 하위클래스의 문제점

1. 하위클래스를 사용하면 되돌리기가 쉽지 않다. 추상클래스를 사용한 후 하위클래스가 표현하고자 하는 변형을 효과적으로 나타내지 못한다고 생각되면 하위클래스를 통해 얽혀 있는 코드를 모두 정리해줘야 한다. 
2. 하위클래스를 이해하기 위해서는 먼저 상위클래스를 이해해야 한다. 상위클래스가 점점 복잡해지면서 이 문제는 더욱 심각해진다.
3. 하위클래스가 상위클래스 세부 구현 특성에 의존할 수 있으므로 상위클래스의 수정이 위험해진다. 
4. 클래스 상속 계층이 복잡해지면서 이 모든 문제가 심화된다.

상속을 사용할 때 특히 치명적인 문제는 병렬 클래스 계층을 이용하는 경우이다. 이 경우, 하나의 클래스 계층에 있는 각 하위클래스에 대해 다른 클래스 계층에 대응되는 하위클래스가 필요하다. 이는 일종의 중복으로서, 클래스 계층간 암묵적 의존관계를 형성한다.

![](/assets/하위클래스의_단점.png)

위 그림은 뭔가 잘못 되어있다. 보험 계약은 연금 상품을 참조하면 안 된다. 그렇다고 계약 클래스에서 상품을 참조하게 하는 것도 그다지 매력적이지 않다. 이럴 경우 해결책은 계약 클래스가 보험 상품과 연금 상품에 상관 없이 동작하게 하는 방법이 있다.\(물론 다른 방법이 있을 수 있음\)

![](/assets/하위클래스_개선.png)

위 그림에서 처럼 현금흐름 이라는 클래스가 생겨 병렬 클래스 계층이용을 방지할 수 있다.

**조건문을 사용한 경우, 하위클래스를 사용한 경우, 위임을 사용한 경우를 모두 상상해보라. 그리고 상대적 강점이 있는 전략을 구현하고 코드가 향상되었는지 살펴보라**

하위크래스 사용을 제한하는 마지막 요소는 동적으로 변화하는 로직을 나타낼 수 없다는 것이다. \(컴파일 타임 의존\) 하위클래스를 사용하는 경우, 객체를 생성할 때 그 객체의 목적을 알아야하며 이는 이후에 바뀔 수 없다. 변화하는 로직을 나타낼 때는 조건문이나 위임을 사용하라.

# 인스턴스별 행위

---

이론상 클래스의 인스턴스들은 모두 같은 로직을 공유한다.

인스턴스별 행동에 따른 비용은 더욱 커진다. 코드를 쉽게 이해시키기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 ㅍㅕㄴ이 좋다.

## 조건문

가장 단순한 인스턴스별 행위의 형태는 if, switch 구문을 이용하는 것이다. 조건문을 사용하면 데이터에 따라 인스턴스는 다른 로직을 수행하게 된다. 조건문의 장점은 인스턴스별 행동을 지원하면서도 모든 로직이 하나의 클래스 안에 들어있다는 것이다.

조건문이 들어간 메소드를 호출하는 코드가 많으면 많을수록 프로그램에 문제가 있을 확률이 높아진다.

아래와 같은 코드가 있을 때 display\(\) 함수를 사용하는 어느 한곳에 기능이 변경되면 display\(\) 내부의 로직이 변경되어야 하고 내부의 로직이 변할 때 또 조건문이 들어가야한다. 추가적으로 조건문이 복사되면 문제는 심각해진다.

```java
class Figure {
    public void display() {
        switch (getType()) {
            case RECTABLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }

    public boolean contains(Point p) {
        switch (getType()) {
            case RECTABLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }
}
```

위 Figure 클래스에서 새로운 도형을 지원해야 한다고 생각해보자. 먼저 모든 switch 문에 새로운로직을 삽입해야한다. 또 기존 코드에 문제가 발생하는 위험을 감수하고, Figure 클래스를 직접 수정해야 한다. 게다가 **새로운 도형 **을 추가하려는 사람들은 같은 클래스의 비슷한 로직 변경을 모두 공유해야한다.

이와 같은 문제는 하위클래스나 위임 중 더 적합한 방법을 사용해서 조건문을 메시지\(다른 객체의 함수 호출\) 로 바꾸면 해결할 수 있다.

![](/assets/추상메소드와_위임.png)

조건문은 단순성과 지역성에서 장점이 있지만, 광법위하게 사용되는 경우 이러한 장점이 문제가 될 수도 있다.

## 위임

인스턴스별 다른 행위를 수행하는 다른 방법으로는 위임이 있다.

위임을 사용하는 예로 그래픽 편집기에서 사용자 입력을 처리하는 경우를 생각해보자. 그래픽 편집기에서 버튼을 누르면 "직사각형", "원","도형이동"을 수행해야 할 수도있다.

조건문 대신 하위클래스나 위임을 선택하면 된다. 프로그램 수행 도중에 편집기가 도구를 바꿔야 하기 때문에 하위클래스는 적당한 해결책이 아니다. 아래와 같이 위임을 통해 코드에 유연성을 부여할 수 있다.

하지만 mouseDown\(\) 메소드가 여러 클래스에 분산되어 구현되므로\(하위클래스도 마찬가지\) 코드를 읽기 어려워졌다. 또한 편집기의 동작을 이해하기 위해서는 어떤 도구가 현재 사용되고 있는지 알아야한다.\(하위클래스에서는 컴파일 타임 의존이므로 알기 쉽다.\)

```java
GraphicEditor
public void mousDown() {
    getTool().mouseDown(this);
}

RectangleTool
public void mouseDown(GraphicEditor editor) {
    editor.add(new RectableFigure());
}
```

위의 코드는 위임에 좀더 용용된 위임자 클래스\(editor\)를 위임 메소드\(mouseDown\)에 인자로 넘겨주는 방식으로 사용한다. 위임을 사용해서 자기 자신에게 메시지를 보낸다면\(위 코드에서 editor.add 메소드를 호출하는 부분\) 자기 자신\(editor\)이 무엇인지 분명하지 않다.

이런 유연성이 불필요하다면 아래와 같이 필드참조로 가지고 있는 것이 간단하다.

# 결론

---

추상 클래스와 자바 인터페이스의 장단점은 인터페이스 수정의 용이성과 단일 클래스가 여러 인터페이스를 지원할 수 있느지 여부로 귀결된다. 인터페이스를 고치면 그 인터페이스를 구현한 모든 클래스도 따라 고쳐야 한다. 널리 사용된 인터페이스를 수정하면 기존 구현이 마비된다. 점진적으로 설계를 향사ㅇ시키려면 버전 인터페이스를 사용해야 한다.

추상 클래스에는 이런 문제가 없다. 기본 구현을 사용할 수 있는 길이 열려 있는 한, 기존 설계를 망가뜨리지 않고 새로운 연산을 얼마든지 추가할 수 있다. 

