# 클래스

### 응집력

###

### static은 나쁘다

StringUtil같은 오직 static으로만 되어 있는 클래스를 사용하는 코드는 많을 것이다. 이 메소드가 나쁠까? 아마 그렇게 나쁘진 않아 보인다. 하지만 StringUtil 같은 일반적인 콘텐드 보다 더 복잡해진다면 나빠질 것이다. 왜냐하면 우리의 코드가 static 메소드와 강하게 결합되기 때문이다. 이 static 메소드 호출을 다른 참조(더 좋은 StringUtil)로 바꾸기 쉬운 방법은 없다. 이와 같이 목킹이 어렵기 때문에 테스트 하기가 어렵다.

static 메소드를 쉽게 목킹할 수 있도록 DI를 받게 해보자~

1단계
```java
public class Utility {
  public static int doSomething() {
    //...
  }
}

public class Client {
  public void foo() {
    Utility.doSomething();
  }
}
```

2단계
```java
public class Utility {
  public int doSomething() {
    //...
  }
}

public class Client{
    public void foo(){
        //…
        new Utility().doSomething();
        //…
    }
}
```

3단계
```java
public class Utility{
    public int doSomething(){
        //…
    }
}
public class Client{
    private final Utility utility;
    public Client(Utility aUtility){
        utility = aUtility;
    }
    public void foo(){
        //…
        utility.doSomething();
        //…
    }
}
```

* 참고
[Why Static is Bad and How to Avoid It](https://dzone.com/articles/why-static-bad-and-how-avoid)

### 싱글톤

싱글톤은 장점이 있는 패턴이지만 최근 몇년간 안티패턴으로 바뀌었다. 싱글톤은 GoF 패턴에서 가장 쉽게 접할 수 있는 패턴이다. 하지만 단점이 많다.

1. 싱글톤은 일반적으로 글로벌 인스턴스처럼 사용된다. 이게 안 좋은 이유는 코드에서 의존성을 숨기기 때문이다.
2. static 사용시와 같이 테스트를 어렵게 한다.
3. 하위 클래스를 만들기 어렵다.

싱글톤은 다양한

* [What is so bad about singletons?](https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons)

### 생성자가 할일

생성자에서 얼마나 많은 작업이 완료되어야 할까? 생성자 안에서 연산은 타당해보일 뿐만 아니라 결과를 감춰주기 까지 한다. 그래서 생성자에서 계산된 결과가 오브젝트 메소드(getter 같은)에 의해 필요하게 될때 우리는 준비된(미리 계산된) 결과를 사용할 수 있다. 이 말만 놓고는 성능적으로 좋아보이고 가능한 로직 같다. 하지만 아니다. 그 이유는 오브젝트의 합성을 막고, 확장 불가능하게 만들고, 테스트를 어렵게 하고, 마지막으로 깨끗한 코드의 원칙인 SRP를 위반하기 때문이다.

우리의 코드는 보통 생성자에서 파일을 열거나, 소켓을 만들고, 메시지 큐를 만드는 등의 일을 한다. 이러한 코드는 아래와 비슷하게 보여진다.

```java
private Config readValue;
public FileBasedConfigProvider(String fileName) {
  //...
  try {
      Path path = Paths.get(fileName);
      byte[] configContent = Files.readAllBytes(path);
      ObjectMapper mapper = new ObjectMapper();
      readValue = mapper.readValue(configContent, Config.class);
  } catch (IOException e) {
      throw new IllegalStateException(e);
  }
  //...
}
```

위와 같은 코드에서 첫번째 문제는 사용과 테스트가 어렵다는 것 이다. 위 코드의 프로바이더를 사용하려면 올바른 파일이름을 알아야 하고, 파일은 Json이어야 하고, Json은 Config로 생성이 되어야 한다. 이 모든 부분이 코드로 표현되어 있지 않기 때문에 생성로직을 알고 사용해야 한다. 그리고 위 코드에서 파일을 읽는 부분이나 오브젝트 맵핑 작업을 쉽게 테스트하기 어렵다. 만약 테스트가 되어야 한다면 싱글턴 객체나 static 메소드로 구현해야 할 것이다. 하지만 이 또한 다른 문제점을 발생시킨다.

두번째 문제는 SRP를 위반한다. 위 코드만 봐도 생성자에서 하는 일이 많다. 생성자는 상태를 초기화 해주는 목적이 있다. 위 소스코드에서는 파일을 읽고, 파일을 오브젝트에 맵핑 시키는 책임1과, 이것을 전역 변수인 readValue에 할당하는 책임2를 가진다. 이렇게 하나 이상의 책임을 가진다면 예상치 못한 방식으로 잘못 동작하는 취약한 설계를 유발할 것이다.

그리고 다음 문제로 생성자에 로직이 들어간다면 명령형 코드로 빠지기 쉽다. 만약 fileName의 확장자를 검사하는 로직이 들어가다면 조건문으로 예외를 처리하게 될 것이다. 조건문 대신에 새로운 타입으로 이 문제를 해결하게 된다면 아래에 설명하겠지만 DIP를 위반하게 된다.[패턴, 가치, 원칙 참고](oop/패턴_가치_원칙.md)

**_생성자는 비즈니스 로직을 위한 것이 아니다. 이런 코드는 구린내가 나는 거니 얼른 수정하자._**

```java
private Config readValue;
public FileBasedConfigProvider(String fileName)  {
  ConfigFromFileMapper mapper = new ConfigFromFileMapper();  
  //책임 1 & 2
  readValue = mapper.from(fileName);
}

public ConfigFromFileMapper() {
  public Config from(fileName) {
    try {
      //책임1
      Path path = Paths.get(fileName);
      byte[] configContent = Files.readAllBytes(path);
      ObjectMapper mapper = new ObjectMapper();
      return mapper.readValue(configContent, Config.class);
    } catch (IOException) {
      throw new IllegalStateException(e);
    }
  }
}
```

위 코드는 1단계 리팩토링을 진행한 결과이다. 파일을 읽고 Config 객체로 맵핑하는 로직이 생성자에 아직 남아 있어 SRP를 충족하지 못하고, 또한 하나의 책임을 하나의 클래스로 묶고 보니 Mapper가 DIP를 위반한다는 사실도 알게됬다. 그래도 조금 깔끔해 졌다.

```java
private Config readValue;
private FileBasedConfigProvider(ConfigFromFileMapper configMapper, String fileName) {
  try {
    readValue = configMapper.from(fileName)
  } catch (IOException) {
    throw new IllegalStateException(e);
  }
}
```

위와 같이 고쳐보니 구조가 조금은 개선된 것 같다 하지만 아직까지도 Mapper의 from() 메소드를 호출하기 때문에 생성자의 책임이 2개이다.

```java
private Config readValue;
private FileBasedConfigProvider(Config config) {
  readValue = config;
}
```

마지막 리팩토링을 끝냈다. Provider의 생성자는 더이상 config가 어떻게 만들어 져야 하는지 알 필요가 없어졌다.(적당한 클래스 이름이 필요할 것 같다) 그리고 파일을 Config 객체로 맵핑하는 로직도 테스트가 가능해질 여지가 생겼다. 다른 방식의 리팩토링이 아래와 같이 생길 수 있다.

```java
private ConfigFromFileMapper configMapper;
private FileBasedConfigProvider(ConfigFromFileMapper configMapper) {
  this.configMapper = configMapper;
}
```

리팩토링을 하면서 설계가 계선되기 때문이다 두 코드는 현재 정답이 없다. Provider의 책임에 의해서 선택이 달라질 것 같다. 객체들의 그래프를 그려보며 더 좋은 모델링이 될 수 있도록 원하는 쪽으로 리팩토링을 하자.

생성자는 비즈니스 로직을 가지는 것 보다는 상태를 초기화하고 검증하는 로직이 적함함을 리팩토링을 통해 알 수 있었다.
**_생성자는 객체들의 관계를 표현하는데 집중하는 것이 로직을 표현하는 것보다 좋다._**

* 참고
[The Clean Code Talk - Inheritance, Polymorphism, Testing](https://www.youtube.com/watch?v=4F72VULWFvc)
[The Clean Code Talk - Don't Look For Things](https://www.youtube.com/watch?v=RlfLCWKxHJ0)
[Fixing the Constructor Anti-Pattern](https://dzone.com/articles/fixing-the-constructor-anti-pattern)
[Constructors Must Be Code-Free](http://www.yegor256.com/2015/05/07/ctors-must-be-code-free.html)

# 객체

객체의 핵심은 기능을 제공하는 것이다.

**실제로 객체를 정의할 때 사용되는 것은 객체가 제공해야 할 기능이며, 객체가 내부적으로 어떤 데이터를 갖고 있는 지로는 정의되지 않는다.**

# 모델

# 패턴
