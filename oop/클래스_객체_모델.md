# 클래스

## 생성자

### 합성과 명령

(composable-decorators)[http://www.yegor256.com/2015/02/26/composable-decorators.html]

### 생성자가 할일


생성자에서 얼마나 많은 작업이 완료되어야 할까? 생성자 안에서 연산은 타당해보일 뿐만 아니라 결과를 감춰주기 까지 한다. 그래서 결과가 오브젝트 메소드(getter 같은)에 의해 필요하게 될때 우리는 준비된 결과를 사용할 수 있다. 이 말만 놓고는 좋은 로직 같다. 하지만 아니다. 그 이유는 오브젝트의 합성을 막고 확장 불가능하게 만들기 때문이다.

```java
interface Name {
  String first();
}

public final class EnglishName implements Name {
  private final String name;
  public EnglishName(final CharSequence text) {
    this.name = text.toString().split(" ", 2)[0];
  }
  @Override
  public String first() {
    return this.name;
  }
}
```
위의 간단한 코드를 보자. 문제가 없고 빠르다. 생성할 때 text를 미리 잘라놨기 때문에 first() 메소드를 몇번이고 호출해도 상관 없다. 항상 같은 값을 반환하기 때문이다. 그러나 이건 병신같은 생각이다. 아래에서 설명하겠다.

```java
public final class EnglishName implements Name {
  private final CharSequence text;
  public EnglishName(final CharSequence txt) {
    this.text = txt;
  }
  @Override
  public String first() {
    return this.text.toString().split("", 2)[0];
  }
}
```

이게 올바른 설계이다. 검증하기 전에 위에 설명한 합성과 명령의 다른 점을 읽어보길 추천한다. 첫번째 구현은 오브젝트처럼 보이지만 명령형 기능 메소드에 매우 가깝다. 두번째는 진짜 오브젝트다.

첫번재 예제는 new 연산자를 속여서 사용하는 것과 같다. 이것을 static 메소드로 바꿀


(Constructors Must Be Code-Free)[http://www.yegor256.com/2015/05/07/ctors-must-be-code-free.html]

# 객체

객체의 핵심은 기능을 제공하는 것이다.

**실제로 객체를 정의할 때 사용되는 것은 객체가 제공해야 할 기능이며, 객체가 내부적으로 어떤 데이터를 갖고 있는 지로는 정의되지 않는다.**

# 모델

# 패턴
