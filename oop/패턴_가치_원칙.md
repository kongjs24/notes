# 패턴, 가치, 원칙
---

## 왜 코드를 잘 짜야할까?

소프트웨어의 전체 비용은 개발 비용 + 유지 비용이라고 할 수 있다. 유지비용은 이해 비용 + 수정 비용 + 테스트 비용 + 설치 비용이 들어간다.

전체 비용을 줄이기 위해 초기 개발 비용을 줄이는 것은 어리석다. 미래에 코드를 어떻게 수정해야 할지 알수 없기 때문이다. 아무리 고민하더라도 미래에 대비해 완벽한 코드를 짜는 것은 불가능한다.

이러한 불확실성 측면에서 볼때, 당장 이득을 얻을 수 있는 구현이 있다면 이 쪽을 선택하는 편이 낫다. 그렇다고 미래에 대비하지 않고 엉망으로 코드를 짜도 된다는 이야기는 아니다. 왜냐하면 유지비용이 더 올라갈 수도 있기 때문이다.

그래서 모든 프로그래머가 커뮤니케이션하기 쉬운 코드를 짬으로써, 유지 비용을 줄이는 것이다. 이 경우 깔끔한 코드를 통해 코드의 결함이 줄어들고 코드 공유가 쉬워져서 좀더 원할한 개발이 가능하다.

그렇다면 어떻게 커뮤니케이션하기 쉽고 깔끔한 코드를 짤 수 있을까? 깔끔한 코드, 커뮤니케이션 하기 좋은 코드를 짜게끔 도와주는 것이 **_패턴, 가치, 원칙_** 이다.

**_패턴_** 은 지금 당장 무엇을 해야 할지 알려주고, **_가치_** 는 패턴을 사용해야하는 동기를 알려주고, **_원칙_** 은 동기를 행동으로 어떻게 바꿔줄지를 알려준다.

## 패턴
패턴은 프로그래밍의 시간과 에너지를 줄여준다.
각 패턴은 우리가 해결해야하는 문제에 대한 해결책을 제시해 준다. 하지만 모든 문제를 해결해 주진 못한다.
사람의 의사 결졍을 돕는 도구 정도로 생각하는 것이 좋다.

## 가치
가치는 코드의 커뮤니케이션, 단순성, 유연성으로 판단할 수 있다. 이 세가지 가치는 서로 상관관계가 있다.

**커뮤니케이션**

커뮤니케이션에 초점을 맞춰서 프로그래밍을 하면 소프트웨어 개발 비용을 줄일 수 있다.

**단순성**

너무 단순하면(메소드 하나에 복잡한 기능을 한다면) 커뮤니케이션이 저해된다. 너무 복잡해도 저해된다.

**유연성**

어떤 프로그램은 상수를 얻기위해 파일을 읽고, 환경변수 키로 접근하여 얻는다. 왜냐하면 프로그램은 유연해야하기 때문이다. 하지만 발전하는 방향으로 유연해야한다. 앞으로 이득을 얻을 수 있을지 불확실한 패턴의 경우에는 일단 사용을 자제하는 편이 좋다. 유연성은 단순성을 저해시키고 복잡하게 만든다.

## 원칙

**지역적 변화**

코드를 수정할 때 함께 바꿔야 하는 부분이 최소여야 한다.

**최소 중복**

최소 중복 원칙은 지역적 변화 원칙을 돕는다. 같은 코드가 여러 곳에서 반복된다면, 이중 하나를 바꿀 때 다른 중복된 코드들도 모두 바꿔야 할지 여부를 결정해야 한다.
병렬 클래스 계층도 일족의 중복이다.\([클래스, 객체, 모델 참고](클래스_객체_모델.md)\) 프로그램상의 어떤 개념을 수정했을 때 2개 이상의 클래스 계층을 수정해야 한다면, 이러한 수정은 지역적 변화의 원칙을 위배하는 것이다.

**로직과 데이터의 결합**

지역적 변화의 원칙에 근거하여 클래스를 설계할 때 로직과 데이터를 함께 유지한다.

**대칭성**

```java
interface List {
  void add();
}
```

메소드 이름을 정할 때 대칭적으로 지으면 사용자가 동작을 예측하기 쉬워진다. 예를들어 위 코드에서 add가 있다면 remove도 있으면 좋다.

```java
void process() {
  input()
  incrementalCount()
  output()
}
```

위 코드를 봤을 때 여기서 incrementalCount는 process 메소드 내부의 추상적인 표현이 아니라 확실한 구현을 표현한다. 따라서 대칭성에 따라 왜 카운터를 증가시키는지 생각해 봐야한다.

**변화률**

함께 변하는 로직과 데이터를 함께 관리하고, 변화가 다른 로직과 데이터는 분리하는 것이다.
예를들어 일반 세금 계산 루틴을 특정 년도 세금 루팅과 별도로 구현할 것이다. 왜냐하면 내가 다음 해의 세금 계산에 관한 코드를 변경하더라도, 이전 연도에 대한 세금 계산은 영향을 받으면 안되기 때문이다.
대칭적인 필드를 별도의 클래스로 묶어서 대칭성을 표현하면, 코드를 읽는 다른 사람에게 프로그래머의 의도를 잘 전달할 수 있고, 중복을 줄일 수 있으며 코드 수정에 대한 영향을 제어하기 쉬워진다.

## 결론

앤터프라이즈 어플리케이션은 혼자서 개발을 하지 않는다. 말 그대로 앤터프라이즈다. 혼자 짠다고 해도 그 많은 클래스의 동작을 머리속에 넣지 못한다. 그렇기 때문에 내가 읽기쉽고 남에게 알리기 쉽게 짜야한다.

패턴, 가치, 원칙 중 한가지만 뛰어날 수 없다. 패턴을 적용할 때 가치가 무엇이고 원칙을 위반하지 않았는지 생각하자.

패턴, 가치, 원칙 중 가치와 원칙은 애자일 설계에서 SOLID라는 개념으로 확장된다.

패턴은 GoF의 디자인 패턴 같은 코드레벨 패턴 외에도 패턴 지향 소프트웨어 설계 패턴도 있다.
