### 클린소프트웨어 발췌

상속과 위임은 모두 상위 단계의 알고리즘을 하위 단계의 구체적인 부분으로부터 분리해주는 역할을 한다. 둘 다 상위 단계의 알고리즘이 구체적인 부분과 독립적으로 재사용될 수 있게 해준다. 약간의 복잡성과 메모리, 실행 시간을 더 감내하면 위임은 구체적인 부분이 상위 단계 알고리즘으로부터 독립적으로 재사옹될 수 있게까지 해준다.

# 상속, 하위클래스

상속 자체는 간단해 보이고 사용하기도 편리하게 느껴지지만 사실 많은 한계점이 있다.

상위클래스의 변경이 있을 때 모든 하위클래스를 변경할 수 있다.\(인터페이스도 구현체가 모두 변경될 수 있다.\)

하위클래스는 상위클래스의 기능을 직접 사용할 수 있다.\(코드 레벨로 제한할 수 없다. 그래서 어디선가 상위 클래스의 기능을 사용한다면 유지보수가 어려워진다.\)

하위클래스를 선언하는 것은 "이 객체는 상위클래스와 같다. 이 부분만 제외하면..." 이라 말하는 것과 같다.

## 하위클래스의 문제점

1. 하위클래스를 사용하면 되돌리기가 쉽지 않다. 하위클래스를 사용한 후 하위클래스가 표현하고자 하는 변형을 효과적으로 나타내지 못한다고 생각되면 하위클래스를 통해 얽혀 있는 코드를 모두 정리해줘야 한다. 
2. 하위클래스를 이해하기 위해서는 먼저 상위클래스를 이해해야 한다. 상위클래스가 점점 복잡해지면서 이 문제는 더욱 심각해진다.
3. 하위클래스가 상위클래스 세부 구현 특성에 의존할 수 있으므로 상위클래스의 수정이 위험해진다. 
4. 클래스 상속 계층이 복잡해지면서 이 모든 문제가 심화된다.

상속을 사용할 때 특히 치명적인 문제는 병렬 클래스 계층을 이용하는 경우이다. 이 경우, 하나의 클래스 계층에 있는 각 하위클래스에 대해 다른 클래스 계층에 대응되는 하위클래스가 필요하다. 이는 일종의 중복으로서, 클래스 계층간 암묵적 의존관계를 형성한다.

![](/assets/스크린샷 2018-01-09 오전 11.28.28.png)

위 그림은 뭔가 잘못 되어있다. 보험 계약은 연금 상품을 참조하면 안 된다. 그렇다고 계약 클래스에서 상품을 참조하게 하는 것도 그다지 매력적이지 않다. 이럴 경우 해결책은 계약 클래스가 보험 상품과 연금 상품에 상관 없이 동작하게 하는 방법이 있다.\(물론 다른 방법이 있을 수 있음\)

![](/assets/스크린샷 2018-01-09 오전 11.31.13.png)

위 그림에서 처럼 현금흐름 이라는 클래스가 생겨 병렬 클래스 계층이용을 방지할 수 있다.

#### 조건문을 사용한 경우, 하위클래스를 사용한 경우, 위임을 사용한 경우를 모두 상상해보라. 그리고 상대적 강점이 있는 전략을 구현하고 코드가 향상되었는지 살펴보라

하위크래스 사용을 제한하는 마지막 요소는 동적으로 변화하는 로직을 나타낼 수 없다는 것이다. \(컴파일 타임 의존\) 하위클래스를 사용하는 경우, 객체를 생성할 때 그 객체의 목적을 알아야하며 이는 이후에 바뀔 수 없다. 변화하는 로직을 나타낼 때는 조건문이나 위임을 사용하라.

# 인스턴스별 행위

이론상 클래스의 인스턴스들은 모두 같은 로직을 공유한다.

인스턴스별 행동에 따른 비용은 더욱 커진다. 코드를 쉽게 이해시키기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 ㅍㅕㄴ이 좋다.

## 행위를 부여하는 조건문

가장 단순한 인스턴스별 행위의 형태는 if, switch 구문을 이용하는 것이다. 조건문을 사용하면 데이터에 따라 인스턴스는 다른 로직을 수행하게 된다. 조건문의 장점은 인스턴스별 행동을 지원하면서도 모든 로직이 하나의 클래스 안에 들어있다는 것이다.

조건문이 들어간 메소드를 호출하는 코드가 많으면 많을수록 프로그램에 문제가 있을 확률이 높아진다.

아래와 같은 코드가 있을 때 display\(\) 함수를 사용하는 어느 한곳에 기능이 변경되면 display\(\) 내부의 로직이 변경되어야 하고 내부의 로직이 변할 때 또 조건문이 들어가야한다. 추가적으로 조건문이 복사되면 문제는 심각해진다.

```
class Figure {
    public void display() {
        switch (getType()) {
            case RECTABLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }

    public boolean contains(Point p) {
        switch (getType()) {
            case RECTABLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }
}
```

위 Figure 클래스에서 새로운 도형을 지원해야 한다고 생각해보자. 먼저 모든 switch 문에 새로운로직을 삽입해야한다. 또 기존 코드에 문제가 발생하는 위험을 감수하고, Figure 클래스를 직접 수정해야 한다. 게다가 **새로운 도형**을 추가하려는 사람들은 같은 클래스의 비슷한 로직 변경을 모두 공유해야한다.

이와 같은 문제는 하위클래스나 위임 중 더 적합한 방법을 사용해서 조건문을 메시지\(다른 객체의 함수 호출\) 로 바꾸면 해결할 수 있다.

![](/assets/스크린샷 2018-01-09 오후 1.43.10.png)

조건문은 단순성과 지역성에서 장점이 있지만, 광법위하게 사용되는 경우 이러한 장점이 문제가 될 수도 있다.

# 위임

인스턴스별 다른 행위를 수행하는 다른 방법으로 

