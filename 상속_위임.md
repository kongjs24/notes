### 객체

객체의 핵심은 기능을 제공하는 것이다.

**실제로 객체를 정의할 때 사용되는 것은 객체가 제공해야 할 기능이며, 객체가 내부적으로 어떤 데이터를 갖고 있는 지로는 정의되지 않는다.**

### DIP

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

하위 수준의 모듈에 의존하는 상위 수준의 모듈이 의미하는 바를 생각해보자. 어떤 애플리케이션의 중요한 정책 의사결정과 업무 모델을 포함하고 있는 것은 상위 수준의 모듈로서, 이 모듈은 애플리케이션의 본질을 담고 있다. 그러나 이런 모듈이 하위 수준의 모듈에 의존할 때, 하위 수준 모듈의 변경은 상위 수준 모듈에 직접적인 영향을 미칠 수 있고, 이번엔 상위 수준의 모듈이 번경되게 할 수도 있다. 이런 상황은 피애햐 한다.

```java
public class Super {
  private ConcreteSub sub = new ConcreteSub();

  public String process()  {
    return sub.doSomething();
  }
}

class ConcreteSub {
  public String doSomething() {
    return "foo";
  }
}

```
위 코드를 보자. super 클래스에서 하위 모듈인 ConcreteSub클래스를 직접 의존하고 있다. 이는 DIP 위반이다.
아래는 ConcreteSub를 Sub 인터페이스로 분리하여(Strategy 패턴) 추상 타입에 의존한 예이다.

```java
public class Super {
  private Sub sub = new ConcreteSub();

  public String process() {
    return sub.doSomething();
  }
}

interface Sub {
  public String doSomething();
}

class ConcreteSub {
  public String doSomething() {
    return "foo";
  }
}
```

### TemplateMethod 패턴 vs Strategy 패턴

```java
abstract class Super {
  public void process() {
    doSomething();
  }
  protected void doSomething();
}

class Sub1 extends Super{
  protected void doSomething() {
    System.out.println("good");
  }
}
```

템플릿 메소드 패턴은 객체 지향 프로그래밍에서 고전적인 재사용 형태 중의 하나를 보여준다. 일반적인 알고리즘은 상위 클래스에 있고, 다른 체적인 내용에서 상속된다. 상속은 아주 강한 관계여서, 파생 클래스는 필연적으로 기반 클래스에 묶이게 된다.

위 예제에서 하위 클래스의 protected 구현체들은 다른 곳에서 필요로 함에도 불구하고 재사용할 방법이 없어진다. 상위클래스를 상속함으로써 상위클래스와 영원히 묶이게끔 결정해버린 것이다.

템플릿 메소드를 사용한 접근은 하위 클래스의 메소드가 상위 클래스에서 직접 의존하도록 구현함으로써 부분적으로 DIP를 위반한다. 전략 패턴을 사용한 접근은 이런 의존성을 포함하고 있지 않다.

상속과 위임은 모두 상위 단계의 알고리즘을 하위 단계의 구체적인 부분으로부터 분리해주는 역할을 한다. 둘 다 상위 단계의 알고리즘이 구체적인 부분과 독립적으로 재사용될 수 있게 해준다. 약간의 복잡성과 메모리, 실행 시간을 더 감내하면 위임은 구체적인 부분이 상위 단계 알고리즘으로부터 독립적으로 재사옹될 수 있게까지 해준다.

### 하위클래스

하위클래스를 사용할 때 특히 치명적인 문제는 병렬 클래스 계층을 이용하는 경우이다. 이 경우, 하나의 클래스 계층에 있는 각 하위클래스에 대해 다른 클래스 계층에 대응되는 하위클래스가 필요하다. 이는 일종의 중복으로서, 클래스 계층간 암묵적 의존관계를 형성한다.

![](/assets/하위클래스의_단점.png)

위 그림을 보고 보험계약은 보험상품만, 즉 해당 계약은 그에 따른 상품만을 가져야한다는 규칙이 있다고 가정하자. 그런데 위 그림은 뭔가 잘못 되어있다. 보험 계약은 연금 상품을 참조하면 안 된다. 그렇다고 계약 클래스에서 상품을 참조하게 하는 것도 그다지 매력적이지 않다. 이럴 경우 해결책은 계약 클래스가 보험 상품과 연금 상품에 상관 없이 동작하게 하는 방법이 있다.

![](/assets/하위클래스_개선.png)

위 그림에서 처럼 현금흐름 이라는 클래스가 생겨 병렬 클래스 계층이용을 방지할 수 있다.\(물론 다른 방법이 있을 수 있음\)

하위클래스는 동적으로 변화하는 로직을 나타낼 수 없다는 것이다. \(컴파일 타임 의존\) 하위클래스를 사용하는 경우, 객체를 생성할 때 그 객체의 목적을 알아야하며 이는 이후에 바뀔 수 없다. 변화하는 로직을 나타낼 때는 조건문이나 위임을 사용하라.

# 인터페이스

---

## 개요

자바 인터페이스를 사용하는 것은 "여기까지가 내가 원하는 것이고, 이외의 내용은 상관하지 않는다." 라고 이야기하는 것과 같다.

인터페이스는 연산만을 나타내므로 사용자는 구현이 변경되더라도 신경 쓸 필요가 없다.

## 인터페이스 문제점

인터페이스를 사용하면 구현을 바꾸는 것은 쉽지만, 인터페이스 자체를 바꾸기는 쉽지 않다. 인터페이스를 수정하면 그 인터페이스를 구현하는 모든 클래스를 수정해야 한다.

따라서 모든 구현을 바꾸는 것이 쉽지 않은 경우라면 전체 설계를 개선하기는 어렵다.

인터페이스를 사용해서 커뮤니케이션에 방해가 되는 한 가지 요인이 있다면, 모든 연산이 공용\(public\)이어야 한다는 점이다.

## 버전 인터페이스

인터페이스를 바꾸고 싶은데 바꿀 수 없는 경우는 아래 코드와 같이 버전 인터페이스를 사용한다.

```java
interface Command {
  void run();
}

interface ReversibleCommand extends Command {
  void undo();
}
```

```java
...
Command recent = ...;
if (recent instanceof ReversibleCommand) {
  ReversibleCommand downcasted = (ReversibleCommand) recent;
  downcasted.undo();
}
...
```
instanceof를 사용하는 경우, 코드가 특정 클래스에 제한되므로 유연성이 떨어지지만 인터페이스 개선을 위해 사용이 불가피하다.

이는 설계를 수정할 때가 되었다는 신호다. 설계를 개선하는게 맞지만 불가피할때를 대비하여 사용법을 알아두는 편이 좋다.

# 추상클래스 \(abstract\)

---

## 개요

하위클래스를 선언하는 것은 "이 객체는 상위클래스와 같다. 이 부분만 제외하면..." 이라 말하는 것과 같다.

추상 클래스에는 기본 구현을 사용할 수 있는 길이 열려 있는 한, 기존 설계를 망가뜨리지 않고 새로운 연산을 얼마든지 추가할 수 있다.

상속을 사용하면 쉽게 다른 클래스의 기능을 재사용 하면서 추가기능을 확장할 수 있다.

상속 자체는 간단해 보이고 사용하기도 편리하게 느껴지지만 사실 많은 한계점이 있다.\(아래 상속의 문제점 확인\)

상위클래스의 변경이 있을 때 모든 하위클래스를 변경할 수 있다. \(인터페이스도 마찬가지로 구현체가 모두 변경될 수 있다.\)

하위클래스는 상위클래스의 기능을 직접 사용할 수 있다. \(코드 레벨로 제한할 수 없다. 그래서 하위클래스 어디선가 상위 클래스의 기능을 사용한다면 유지보수가 어려워진다.\)

## 상속의 문제점

1. 상위 클래스 변경이 어렵다. 어떤 클래스를 상속받는다는 것은 그 클래스에 의존한다는 듯이다. 계층이 많아질 수록 상위 클래스의 변경이 어려워진다. 최악의 경우 상위 클래스의 변화가 모든 하위 클래스에 영향을 줄 수 있다. 이는 클래스 계층도에 있는 클래스들을 한 개의 거대한 단일 구조처럼 만들어 주는 결과를 낸다.
2. 1번 문제에 추가적으로 하위클래스가 상위클래스 세부 구현 함수에 의존할 수 있으므로 상위클래스의 수정이 위험해진다.

![](/assets/spring_controller_hierarchy.png)
위 그림은 스프링 컨트롤러 계층도이다. 여기서 AbstractController를 수정하면 의존하는 하위클래스들에 변경의 여파가 계층도를 따라 전파된다.

3. 유사한 기능을 확장하는 과정에서 클래스의 개수가 불필요하게 증가할 수 있다.

![](/assets/상속_단점2.png)
위 그림으로 예를 들어 보자.
파일 보관소를 구현한 Storage 클래스가 있다고 할 때, 제품이 출시된 이후 보관소의 용량을 아낄 수 있는 방법을 제공해 달라는 요구가 발생하였다. 이 요구를 수용하기 위해 Storage클래스를 상속받아 압축 기능을 추가한 CompressedStorage 클래스를 만들었다. 또, 보안이 문제가 되서 암호화해서 저장해 주는 EncryptedStorage 클래스를 추가하였다.

그런데 만약 압축을 먼저하고 암호화 하는 저장소가 필요하다면? 또 암호화를 먼저하고 압축을 해달라고 하면? 추가로 암호화된 저장소에 캐시를 적용하려면? 아래와 같은 클래스 계층이 만들어질 것이다.

다중 상속을 할 수 없는 자바에서는 한 개의 클래스만 상속받고 다른 기능은 별도로 구현해야 한다.

4. 하위클래스에서 코드를 복사한 후 일부 수정하게 되면 암묵적인 의존 관계가 생긴다.

```java
class Super {
  public void method() {
    1
    2
    3
  }
}
class Sub extends Super {
    @override
    public void method() {
      1
      2-1
      3
      4
    }
}
```

5. 클래스 상속 계층이 복잡해지면서 이 모든 문제가 심화된다.

# 인스턴스별 행위

---

이론상 클래스의 인스턴스들은 모두 같은 로직을 공유한다.

인스턴스별 행동에 따른 비용은 더욱 커진다. 코드를 쉽게 이해시키기 위해서는 인스턴스 생성 후에는 인스턴스별 행동을 변화시키지 않는 편이 좋다.

## 조건문

가장 단순한 인스턴스별 행위의 형태는 if, switch 구문을 이용하는 것이다. 조건문을 사용하면 데이터에 따라 인스턴스는 다른 로직을 수행하게 된다. 조건문의 장점은 인스턴스별 행동을 지원하면서도 모든 로직이 하나의 클래스 안에 들어있다는 것이다.

조건문이 들어간 메소드를 호출하는 코드가 많으면 많을수록 프로그램에 문제가 있을 확률이 높아진다.

아래와 같은 코드가 있을 때 display\(\) 함수를 사용하는 어느 한곳에 기능이 변경되면 display\(\) 내부의 로직이 변경되어야 하고 내부의 로직이 변할 때 또 조건문이 들어가야한다. 추가적으로 조건문이 복사되면 문제는 심각해진다.

```java
class Figure {
    public void display() {
        switch (getType()) {
            case RECTANGLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }

    public boolean contains(Point p) {
        switch (getType()) {
            case RECTANGLE :
                //...
                break;
            case TEST :
                //...
                break;
            default :
                break;
        }
    }
}
```

위 Figure 클래스에서 새로운 도형을 지원해야 한다고 생각해보자. 먼저 모든 switch 문에 새로운로직을 삽입해야한다. 또 기존 코드에 문제가 발생하는 위험을 감수하고, Figure 클래스를 직접 수정해야 한다. 게다가 **새로운 도형** 을 추가하려는 사람들은 같은 클래스의 비슷한 로직 변경을 모두 공유해야한다.

이와 같은 문제는 하위클래스나 위임 중 더 적합한 방법을 사용해서 조건문을 메시지\(다른 객체의 함수 호출\) 로 바꾸면 해결할 수 있다.

![](/assets/추상메소드와_위임.png)

조건문은 단순성과 지역성에서 장점이 있지만, 광법위하게 사용되는 경우 이러한 장점이 문제가 될 수도 있다.

데이터를 두고 여러 프로시저들이 생겨나는 절차지향 프로그래밍에서 많이 보인다.


## 위임(조립)

인스턴스별 다른 행위를 수행하는 다른 방법으로는 위임이 있다.

위임을 사용하는 예로 그래픽 편집기에서 사용자 입력을 처리하는 경우를 생각해보자. 그래픽 편집기에서 버튼을 누르면 "직사각형", "원","도형이동"을 수행해야 할 수도있다.

조건문 대신 하위클래스나 위임을 선택하면 된다. 프로그램 수행 도중에 편집기가 도구를 바꿔야 하기 때문에 하위클래스는 적당한 해결책이 아니다. 아래와 같이 위임을 통해 코드에 유연성을 부여할 수 있다.

하지만 mouseDown\(\) 메소드가 여러 클래스에 분산되어 구현되므로\(하위클래스도 마찬가지\) 코드를 읽기 어려워졌다. 또한 편집기의 동작을 이해하기 위해서는 어떤 도구가 현재 사용되고 있는지 알아야한다.\(하위클래스에서는 컴파일 타임 의존이므로 알기 쉽다.\)

```java
GraphicEditor
public void mouseDown() {
    getTool().mouseDown(this);
}

RectangleTool
public void mouseDown(GraphicEditor editor) {
    editor.add(new RectangleFigure());
}
```

위의 코드는 위임에 좀더 용용된 위임자 클래스\(editor\)를 위임 메소드\(mouseDown\)에 인자로 넘겨주는 방식으로 사용한다. 위임\(RectangleTool에 기능을 위임\)을 사용해서 자기 자신\(editor\)에게 메시지를 보낸다면\(위 코드에서 editor.add 메소드를 호출하는 부분\) 자기 자신\(editor\)이 무엇인지 분명하지 않다.

위와 같은 유연성이 불필요하다면 아래와 같이 필드참조로 가지고 있는 것이 간단하다.

```java
RectangleTool
private GraphicEditor editor;
public RectangleTool(GraphicEditor editor) {
  this.editor = editor;
}

public void mouseDown() {
  editor.add(new RectangleFigure());
}
```

# 결론

---

추상 클래스와 자바 인터페이스의 장단점은 인터페이스 수정의 용이성과 단일 클래스가 여러 인터페이스를 지원할 수 있느지 여부로 귀결된다. 인터페이스를 고치면 그 인터페이스를 구현한 모든 클래스도 따라 고쳐야 한다. 점진적으로 설계를 개선하려면 버전 인터페이스를 사용해야 한다.

추상 클래스에는 기본 구현을 사용할 수 있는 길이 열려 있는 한, 기존 설계를 망가뜨리지 않고 새로운 연산을 얼마든지 추가할 수 있다. 하지만 추상화를 진행하다 보면, 쓸데없는 추상 클래스를 너무 많이 만들게 되는 경우가 생간다. 추상클래스가 많아지면 위의 하위클래스 문제점이 나타나게 될수 있다. 이럴 때 최상위 클래스를 인스턴스화 가능한 클래스로 만들면 쓸데 없는 추상 클래스 계층을 제거할 수 있다.

인터페이스 계층과 클레스 계층은 서로 배타적인 것이 아님을 유념하자.

도메인 모델 설계 시 행위를 뺀 설계는 객체 지향 설계가 아닌 자료구조\(DTO\) 설계다.!

인터페이스는 단점이 명확히 보인다. 추상클래스는 단점을 처음에는 모르는게 단점이다.\(설계할 때 중요\)

**조건문을 사용한 경우, 하위클래스를 사용한 경우, 위임을 사용한 경우를 모두 상상해보라. 그리고 상대적 강점이 있는 전략을 구현하고 코드가 향상되었는지 살펴보라**
